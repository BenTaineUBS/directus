import { findWorkspaceDir } from '@pnpm/find-workspace-dir';
import { Project, findWorkspacePackagesNoCheck } from '@pnpm/find-workspace-packages';
import { existsSync, unlinkSync } from 'node:fs';
import { join } from 'node:path';
import { MAIN_PACKAGE, PACKAGE_ORDER, UNTYPED_PACKAGES } from './constants';
import type { Package, PackageVersion } from './types';

export async function processPackages(): Promise<{
	mainVersion: string | undefined;
	packageVersions: PackageVersion[];
}> {
	const workspacePackages = await getPackages();
	let mainVersion;
	const packageVersionMap = new Map<string, string>();

	for (const localPackage of workspacePackages) {
		const { name, version } = localPackage.manifest;

		if (name === MAIN_PACKAGE) {
			mainVersion = version;
		}

		const changelogPath = join(localPackage.dir, 'CHANGELOG.md');

		if (existsSync(changelogPath)) {
			// The package has been bumped if a changelog file is generated
			// (also catching packages only containing dependency updates from changeset)
			if (name && version) {
				packageVersionMap.set(name, version);
			}

			// Fix packages without 'version' wrongly set to 'null' by changeset
			if (version === null) {
				const { version: _version, ...manifest } = localPackage.manifest;
				await localPackage.writeProjectManifest(manifest);
			}

			// Clean-up changelog files generated by changeset in favor of release notes
			unlinkSync(changelogPath);
		}
	}

	const packageVersions: PackageVersion[] = Array.from(packageVersionMap, ([name, version]) => ({
		name,
		version,
	}))
		.filter(({ name }) => ![MAIN_PACKAGE, ...Object.keys(UNTYPED_PACKAGES)].includes(name))
		.sort(sortPackages);

	return { mainVersion, packageVersions };
}

async function getPackages(): Promise<Project[]> {
	const workspaceRoot = await findWorkspaceDir(process.cwd());

	if (!workspaceRoot) {
		throw new Error(`Couldn't locate workspace root`);
	}

	return findWorkspacePackagesNoCheck(workspaceRoot);
}

export function sortPackages(a: Package | PackageVersion, b: Package | PackageVersion): number {
	const indexOfA = PACKAGE_ORDER.indexOf(a.name);
	const indexOfB = PACKAGE_ORDER.indexOf(b.name);
	if (indexOfA >= 0 && indexOfB >= 0) return indexOfA - indexOfB;

	if (indexOfA >= 0) {
		return -1;
	}

	return 0;
}
