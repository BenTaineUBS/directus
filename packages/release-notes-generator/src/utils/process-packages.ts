import { findWorkspaceDir } from '@pnpm/find-workspace-dir';
import { Project, findWorkspacePackagesNoCheck } from '@pnpm/find-workspace-packages';
import { existsSync, unlinkSync } from 'node:fs';
import { join } from 'node:path';
import semver, { inc } from 'semver';
import { LINKED_PACKAGES, MAIN_PACKAGE, PACKAGE_ORDER, UNTYPED_PACKAGES } from '../constants.js';
import type { PackageVersion } from '../types.js';
import { sortByExternalOrder } from './sort.js';

export async function processPackages(): Promise<{
	mainVersion: string | undefined;
	packageVersions: PackageVersion[];
}> {
	const workspacePackages = await getPackages();
	const packageVersionMap = new Map<string, string>();

	for (const localPackage of workspacePackages) {
		const { name, version } = localPackage.manifest;

		if (!name) {
			continue;
		}

		const changelogPath = join(localPackage.dir, 'CHANGELOG.md');

		// The package has been bumped if a changelog file is generated
		// (also catching packages bumped only due to internal dependency updates from changeset)
		if (existsSync(changelogPath)) {
			if (version) {
				packageVersionMap.set(name, version);
			} else if (version === null) {
				// Fix 'version' field in unversioned packages wrongly set to 'null' by changeset
				const { version: _version, ...manifest } = localPackage.manifest;
				await localPackage.writeProjectManifest(manifest);
			}

			// Remove changelog files generated by changeset in favor of release notes
			unlinkSync(changelogPath);
		}
	}

	const mainVersion = semver.parse(process.env['DIRECTUS_VERSION'] ?? packageVersionMap.get(MAIN_PACKAGE));

	if (!mainVersion) {
		throw new Error(`Main version ('${MAIN_PACKAGE}' package) is missing or invalid`);
	}

	const isPrerelese = mainVersion.prerelease.length > 0;

	if (isPrerelese) {
		for (const [name, version] of packageVersionMap) {
			const workspacePackage = workspacePackages.find((p) => p.manifest.name === name);

			if (workspacePackage) {
				const newVersion = `${version}-${mainVersion.prerelease.join('.')}`;

				await workspacePackage.writeProjectManifest({
					...workspacePackage.manifest,
					version: newVersion,
				});

				packageVersionMap.set(name, newVersion);
			}
		}
	}

	for (const [source, target] of LINKED_PACKAGES) {
		if (packageVersionMap.has(source) && !packageVersionMap.has(target)) {
			const workspacePackage = workspacePackages.find((p) => p.manifest.name === target);

			if (workspacePackage && workspacePackage.manifest.version) {
				let bumpedVersion = inc(workspacePackage.manifest.version, 'patch');

				if (isPrerelese) {
					bumpedVersion = `${bumpedVersion}-${mainVersion.prerelease.join('.')}`;
				}

				if (bumpedVersion) {
					await workspacePackage.writeProjectManifest({ ...workspacePackage.manifest, version: bumpedVersion });
					packageVersionMap.set(target, bumpedVersion);
				}
			}
		}
	}

	const packageVersions: PackageVersion[] = Array.from(packageVersionMap, ([name, version]) => ({
		name,
		version,
	}))
		.filter(({ name }) => ![MAIN_PACKAGE, ...Object.keys(UNTYPED_PACKAGES)].includes(name))
		.sort(sortByExternalOrder(PACKAGE_ORDER, 'name'));

	return { mainVersion: mainVersion.version, packageVersions };
}

async function getPackages(): Promise<Project[]> {
	const workspaceRoot = await findWorkspaceDir(process.cwd());

	if (!workspaceRoot) {
		throw new Error(`Couldn't locate workspace root`);
	}

	return findWorkspacePackagesNoCheck(workspaceRoot);
}
